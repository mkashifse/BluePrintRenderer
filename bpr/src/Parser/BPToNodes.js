import Vector from "../libs/vector.js";

import CommentNode from '../Nodes/CommentNode.js';
import EventNode from '../Nodes/EventNode.js';
import FunctionNode from '../Nodes/FunctionNode.js';
import MacroNode from '../Nodes/MacroNode.js';

import GetterNode from '../Nodes/GetterNode.js';
import SetterNode from '../Nodes/SetterNode.js';

import BinaryOperatorNode from '../Nodes/BinaryOperatorNode.js';

import {VAR_TYPES, FUNCTIONS_MAPPING} from '../config.js';


export default function BPToNodes(objects) {
    var origin = origin || new Vector(0, 0);
    var minX, minY;
    var newNodes = [];
    for (var i = 0; i < objects.length; i++) {
        if (objects[i].nodePosX && objects[i].nodePosY) {
            minX = objects[i].nodePosX;
            minY = objects[i].nodePosY;
            break;
        }

    }


    for (var i = 0; i < objects.length; i++) {
        var curObj = objects[i];
        if (parseInt(curObj.nodePosX) < minX)
            minX = curObj.nodePosX;
        if (parseInt(curObj.nodePosY) < minY)
            minY = curObj.nodePosY;
    }

    for (var i = 0; i < objects.length; i++) {
        var curObj = objects[i];
        if (!curObj.nodePosY)
            curObj.nodePosY = 0;
        if (!curObj.nodePosX)
            curObj.nodePosX = 0;
        curObj.nodePosY -= minY;
        curObj.nodePosX -= minX;

        curObj.nodePosY += origin.y;
        curObj.nodePosX += origin.x;
    }

    var maxX = 0, maxY = 0;

    for (var i = 0; i < objects.length; i++) {
        var curObj = objects[i];

        if (parseInt(curObj.nodePosY) + parseInt(curObj.nodeHeight) > maxY)
            maxY = parseInt(curObj.nodePosY) + parseInt(curObj.nodeHeight);

        if (parseInt(curObj.nodePosX) + parseInt(curObj.nodeWidth) > maxX)
            maxX = parseInt(curObj.nodePosX) + parseInt(curObj.nodeWidth);
    }


    var links = [];
    for (var i = 0; i < objects.length; i++) {
        var curObj = objects[i];
        var x, y;
        var newNode = null;
        var nN;
        x = curObj.nodePosX;
        y = curObj.nodePosY;
        if (curObj.class && curObj.class.indexOf("EdGraphNode_Comment") !== -1) {
            newNode = {
                name: curObj.nodeComment,
                width: curObj.nodeWidth,
                height: curObj.nodeHeight
            };
            if (curObj.commentColor)
                newNode.commentColor = curObj.commentColor;
            nN = new CommentNode(newNode, x, y);
            newNodes.push(nN);
        }


    }


    for (var i = 0; i < objects.length; i++) {
        var curObj = objects[i];
        var inputs = [];
        var outputs = [];
        var x, y;
        var newNode = null;
        var nN = null;
        x = curObj.nodePosX;
        y = curObj.nodePosY;

        if (curObj.pins.length === 0) {
            //console.log('empty pins');
            continue
        }

        for (var j = 0; j < curObj.pins.length; j++) {
            var curPin = curObj.pins[j];
            var pinType = VAR_TYPES[curPin.pinSubType] && VAR_TYPES[curPin.pinSubType] || VAR_TYPES[curPin.pinType];
            if (curPin.bHidden === "True")
                continue;

            if (curPin.isOutput) {
                for (var k = 0; k < curPin.linkedTo.length; k++) {
                    links.push({from: curPin.pinId, to: curPin.linkedTo[k]})
                }
            }
            var newPin = {
                name: curPin.pinFriendlyName && curPin.pinFriendlyName || curPin.pinText,
                type: pinType,
                id: curPin.pinId
            };

            if (curPin.pinFriendlyName && curPin.pinFriendlyName.indexOf("NSLOCTEXT") !== -1) {
                var tmp = curPin.pinFriendlyName.replace("NSLOCTEXT(", "").replace(")", "");
                var tmpArr = tmp.split(",");
                newPin.name = tmpArr[tmpArr.length - 1].replace(/["']/g, "");
            }

            if (curPin.pinToolTip) {
                newPin.tooltip = curPin.pinToolTip;
            }

            if (curPin.isArray)
                newPin.isArray = true;
            if (curPin.linkedTo.length > 0)
                newPin.linked = true;
            else
                newPin.linked = false;

            if (!newPin.linked && !curPin.isOutput) {
                if (newPin.type === VAR_TYPES["vector"] || newPin.type === VAR_TYPES["rotator"]) {
                    var tmpValue = curPin.defaultValue && curPin.defaultValue || curPin.autogeneratedDefaultValue;
                    if (tmpValue)
                    {
                        var vect = tmpValue.split(",");
                        for (var z = 0; z < vect.length; z++) {
                            vect[z] = parseFloat(vect[z]).toFixed(1);
                        }
                    } else {
                        vect[0] = 0.0;
                        vect[1] = 0.0;
                        vect[2] = 0.0;
                    }

                    newPin.value = vect;
                } else if (newPin.type === VAR_TYPES["float"] || newPin.type === VAR_TYPES["int"] || newPin.type === VAR_TYPES["byte"]) {
                    newPin.value = curPin.defaultValue && curPin.defaultValue || curPin.autogeneratedDefaultValue;
                    //newPin.value = parseFloat(newPin.value).toFixed(1);
                } else if (newPin.type === VAR_TYPES["bool"]) {
                    newPin.value = curPin.defaultValue && curPin.defaultValue || curPin.autogeneratedDefaultValue;
                    if (newPin.value === "true")
                        newPin.value = true;
                    else
                        newPin.value = false;
                    //newPin.value = parseFloat(newPin.value).toFixed(1);
                } else if (newPin.type === VAR_TYPES["actor"] || newPin.type === VAR_TYPES["object"]) {
                    if (curPin.pinText === "self") {
                        newPin.value = "self";
                    }
                }
            }

            if (curPin.isOutput) {
                outputs.push(newPin);
            } else {
                inputs.push(newPin);
            }
        }

        if (!curObj.class || (inputs.length === 0 && outputs.length === 0)) {
            continue
        }




        if (typeof FUNCTIONS_MAPPING[curObj.class] !== "undefined") {
            var async = false;
            if (FUNCTIONS_MAPPING[curObj.class] !== null) {
                if (FUNCTIONS_MAPPING[curObj.class].text) {
                    curObj.nodeName = FUNCTIONS_MAPPING[curObj.class].text;
                }

                if (FUNCTIONS_MAPPING[curObj.class].async) {
                    async = true;
                }

            }
            newNode = {
                isPure: curObj.bIsPureFunc && curObj.bIsPureFunc === "True",
                name: curObj.nodeName,
                inputs: inputs,
                outputs: outputs
            };

            if (FUNCTIONS_MAPPING[curObj.class] !== null) {
                if (FUNCTIONS_MAPPING[curObj.class].async) {
                    newNode.async = true;
                }
                if (FUNCTIONS_MAPPING[curObj.class].icon) {
                    newNode.icon = FUNCTIONS_MAPPING[curObj.class].icon;
                }

                if (FUNCTIONS_MAPPING[curObj.class].morpher) {
                    FUNCTIONS_MAPPING[curObj.class].morpher(newNode, curObj);
                    //console.log("After morpher",newNode);
                }

            }

            if (curObj.class.indexOf("K2Node_MakeArray") !== -1)
                newNode.isPure = true;

            if (newNode.name.indexOf("Conv_") !== -1 && newNode.name.indexOf("Int To Text") === -1 && newNode.name.indexOf("Float To Text") === -1) {
                //nN = new ConverterNode(newNode, x, y);
            } else if (newNode.name.indexOf("_") !== -1 && newNode.name.indexOf("Get") === -1 && newNode.name.indexOf("Conv") === -1 && newNode.name.indexOf("Set") === -1 && newNode.name.indexOf("Add") === -1 && newNode.name.indexOf("K2") === -1 && newNode.name.indexOf("Montage") === -1 && newNode.name.indexOf("Greater_Vector") === -1 && newNode.name.indexOf("Less_Vector") === -1) {
                nN = new BinaryOperatorNode(newNode, x, y);
            } else {
                nN = new FunctionNode(newNode, x, y);
            }

        } else if (curObj.class.indexOf("K2Node_DynamicCast") !== -1) {
            var tmpArr = curObj.targetType.split(".");
            var name = "Cast to " + tmpArr[tmpArr.length - 1].replace("_C", "").replace(/["']/g, "");
            newNode = {
                name: name,
                inputs: inputs,
                outputs: outputs
            };


            //nN = new CastNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_Timeline") !== -1) {
            newNode = {
                name: curObj.timelineName,
                inputs: inputs,
                outputs: outputs
            };


            //nN = new TimelineNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_CallDelegate") !== -1) {
            // console.log(curObj);
            newNode = {
                name: curObj.nodeName,
                inputs: inputs,
                outputs: outputs
            };


            //nN = new CallDelegateNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_CallArrayFunction") !== -1) {
            newNode = {
                isPure: curObj.bIsPureFunc && curObj.bIsPureFunc === "True",
                name: curObj.nodeName,
                inputs: inputs,
                outputs: outputs
            };
            if (curObj.nodeName.indexOf("_Set") !== -1) {
                nN = new FunctionNode(newNode, x, y);
            } else {
                //nN = new ArrayFunctionNode(newNode, x, y);
            }
        } else if (curObj.class.indexOf("EdGraphNode_Comment") !== -1) {
            continue
        } else if (curObj.class.indexOf("K2Node_MacroInstance") !== -1 || curObj.class.indexOf("K2Node_IfThenElse") !== -1 || curObj.class.indexOf("K2Node_ExecutionSequence") !== -1) {
            if (curObj.class.indexOf("K2Node_IfThenElse") !== -1)
                curObj.nodeName = "Branch"
            else if (curObj.class.indexOf("K2Node_ExecutionSequence") !== -1)
                curObj.nodeName = "Sequence"
            newNode = {
                name: curObj.nodeName,
                inputs: inputs,
                outputs: outputs
            };

            nN = new MacroNode(newNode, x, y);

        } else if (curObj.class.indexOf("K2Node_Event") !== -1 || curObj.class.indexOf("K2Node_CustomEvent") !== -1 || curObj.class.indexOf("K2Node_ComponentBoundEvent") !== -1 || curObj.class.indexOf("K2Node_InputTouch") !== -1 || curObj.class.indexOf("K2Node_InputAction") !== -1 || curObj.class.indexOf("K2Node_InputAxisEvent") !== -1 || curObj.class.indexOf("K2Node_InputKey") !== -1) {
            if (curObj.class && curObj.class.indexOf("K2Node") !== -1)
                curObj.class = curObj.class.replace("K2Node_", "");
            curObj.class = curObj.class.fromCamelCase();
            //console.log("EVENT", curObj);
            newNode = {
                name: curObj.nodeName && curObj.nodeName || curObj.class,
                inputs: inputs,
                outputs: outputs,
                isCustom: curObj.isCustom
            };

            if (curObj.class === "Input Key") {
                newNode.inputKey = curObj.inputKey;
            }

            nN = new EventNode(newNode, x, y);

        } else if (curObj.class.indexOf("K2Node_VariableGet") !== -1 || curObj.class.indexOf("K2Node_Self") !== -1) {
            newNode = {
                outputs: outputs
            };


            nN = new GetterNode(newNode, x, y);

        } else if (curObj.class.indexOf("Set") !== -1) {
            newNode = {
                outputs: outputs,
                inputs: inputs
            };
            nN = new SetterNode(newNode, x, y);
        } else if (curObj.class.indexOf("Operator") !== -1 || curObj.class.indexOf("K2Node_EnumEquality") !== -1) {
            newNode = {
                name: curObj.nodeName && curObj.nodeName || curObj.class,
                inputs: inputs,
                outputs: outputs
            };
            nN = new BinaryOperatorNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_Knot") !== -1) {
            //console.log('KNIT');
            newNode = {
                name: curObj.nodeName && curObj.nodeName || curObj.class,
                inputs: inputs,
                outputs: outputs
            };
            //nN = new RerouteNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_Select") !== -1) {
            newNode = {
                name: "Select",
                inputs: inputs,
                outputs: outputs
            };
            //nN = new SelectNode(newNode, x, y);
        } else if (curObj.class.indexOf("K2Node_Composite") !== -1) {
            newNode = {
                name: curObj.boundGraph.replace("EdGraph", "").replace(/["']/g, ""),
                inputs: inputs,
                outputs: outputs
            };
            //nN = new CompositeNode(newNode, x, y);
        } else {
            newNode = {
                name: curObj.nodeName && curObj.nodeName || curObj.class || curObj.name,
                inputs: inputs,
                outputs: outputs
            };
            if (curObj.class.indexOf("Material") === -1)
                console.log("Unknown Node", curObj);
            //nN = new UnknownNode(newNode, x, y);
        }


        if (nN) {
            newNodes.push(nN);
            nN = null;
            newNode = null;
        }
    }

    for (var i = 0; i < newNodes.length; i++) {
        newNodes[i].init();
    }


    for (var i = 0; i < links.length; i++) {
        var curLink = links[i];
        var from = null;
        var to = null;
        var nodeFrom = null;

        for (var j = 0; j < newNodes.length; j++) {
            for (var z = 0; z < newNodes[j].pinRows.length; z++) {
                var row = newNodes[j].pinRows[z];
                if (row.output && row.output.id === curLink.from) {
                    nodeFrom = newNodes[j];
                    from = row.output;
                }
                if (row.input && row.input.id === curLink.to) {
                    to = row.input;
                    to.parent = newNodes[j];
                }
            }
        }

        if (nodeFrom) {
            if (to) {
                nodeFrom.setOutputLink(from, to);
            }
        }
    }



    return newNodes;
}

